<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="normalize.css" />

    <link rel="stylesheet" type="text/css" href="prettify.css" />
    <script src="prettify.js"></script>

    <link rel="stylesheet" type="text/css" href="index.css" />
  </head>

  <body onload="prettyPrint();">

    <h1>Coroutine Event Loops in Javascript</h1>

    <p>Javascript 1.7, currently only available in Firefox, introduces a <code>yield</code> keyword for implementing generators and coroutines.<p>
    <p>One thing coroutines can be used for is to implement event loops as an alternative to callback functions,
      which makes them particularly interesting in Javascript, where the use of callbacks is pervasive.</p>
    <p>It's not clear to me if Javascript coroutines are actually useful, but at the very least they're interesting to think about.</p>

    <p><strong>If you're in a hurry:</strong> a <a href="test-yield.html">Firefox-only demo</a> of a coroutine event loop, and <a href="https://github.com/hrldcpr/javascript-coroutines/blob/master/test-yield.js">the code</a>.</p>

    <h2>The Basics</h2>

    <p>A coroutine is a function which can suspend itself anywhere in its execution using the <code>yield</code> keyword.</p>
    <p>It can be resumed at any later point by <em>sending</em> a value to the suspended coroutine. The sent value will appear as the return value of <code>yield</code> and execution will resume until the next <code>yield</code>.</p>

    <p>For example we can create a simple coroutine which will yield twice and print out the values that are sent to it after each yield:</p>
<pre class="prettyprint">
function test() {
    console.log('Hello!');
    var x = yield;
    console.log('First I got: ' + x);
    var y = yield;
    console.log('Then I got: ' + y);
}
</pre>

    <p>To initiate an instance of a coroutine you just call the function, which returns a coroutine object:</p>
    <pre class="prettyprint">var tester = test();</pre>
    <p>So far none of the function will have executed, so we must execute the function until it hits a <code>yield</code>, by calling:</p>
    <pre class="prettyprint">tester.send(); // prints 'Hello!'</pre>
    <p>Now <code>tester</code> is paused at the first <code>yield</code>, and we can resume the coroutine by sending a value to the <code>yield</code> where it is paused:</p>
    <pre class="prettyprint">tester.send('a cat'); // prints 'First I got: a cat'</pre>
    <p>Now <code>tester</code> is paused at the second <code>yield</code>, and we can send another value:</p>
    <pre class="prettyprint">tester.send('a dog'); // prints 'Then I got: a dog'</pre>

    <p>That's about all there is to coroutines&mdash;they are functions which can suspend themselves using the <code>yield</code> keyword,
      and you can communicate with them by sending values, which will be returned as the value of <code>yield</code> and resume execution.</p>


    <h2>The Convenient <code>coroutine</code> Wrapper</h2>

    <p>Every time you use a coroutine you always do three things:</p>
    <ol>
      <li>Call the underlying function and store the resulting coroutine object.</li>
      <li>Call <code>send()</code> on the coroutine object, to execute until the first <code>yield</code>.</li>
      <li>After that all you can do is call <code>send(...)</code> to run the coroutine and send it values.</li>
    </ol>

    <p>We can put all of this functionality into a wrapper function:</p>
<pre class="prettyprint">
function coroutine(f) {
    var o = f(); // instantiate the coroutine
    o.send(); // execute until the first yield
    return function(x) {
        o.send(x);
    }
}
</pre>
    <p>This sets up the coroutine and returns a function which we can call directly instead of calling <code>send</code> on the coroutine object.</p>

    <p>Using this wrapper, our earlier example becomes:</p>
<pre class="prettyprint">
var test = coroutine(function() {
    console.log('Hello!');
    var x = yield;
    console.log('First I got: ' + x);
    var y = yield;
    console.log('Then I got: ' + y);
});
// prints 'Hello!'

test('a dog'); // prints 'First I got: a dog'
test('a cat'); // prints 'Then I got: a cat'
</pre>


    <h2>A Coroutine Loop</h2>

    <p>Our first example coroutine yields twice and then ends. Let's make a never-ending coroutine instead.</p>
    <p>Here's a coroutine that never ends, and each time you resume it, it alternates between ticking and tocking:</p>

<pre class="prettyprint">
var clock = coroutine(function() {
    while (true) {
        yield;
        console.log('Tick!');
        yield;
        console.log('Tock!');
    }
});

clock(); // prints 'Tick!'
clock(); // prints 'Tock!'
clock(); // prints 'Tick!'
</pre>

    <p><em>Note that in Javascript, calling <code>clock()</code> with no argument is the same as calling <code>clock(undefined)</code>,
      which in this case is fine since this coroutine doesn't even look at the values being sent to it.</em></p>

    <p>Now let's make the clock tick/tock once every second. It's very easy:</p>
    <pre class="prettyprint">setInterval(clock, 1000);</pre>
    <p>This resumes the coroutine once every 1000ms, and it will tick and tock for eternity.</p>


    <h2>A Coroutine Event Loop</h2>

    <p>Just like we used the <code>clock</code> function above as a timer callback,
      we can use coroutines as callbacks for events,
      and the event object will be sent to the running coroutine.</p>
    <p>For example suppose we want to implement this little demo, where the user can drag a box around:</p>
    <p><iframe src="test.html" width="400px" height="400px"></iframe></p>
    <p>To implement this, we would first listen for a <code>mousedown</code> on the box,
      then process any <code>mousemove</code> events to actually move the box,
      until we see a <code>mouseup</code> event, at which point we're back where we started.</p>

    <p>We can implement this as a coroutine that receives events from <code>yield</code>:</p>
<pre class="prettyprint">
var loop = coroutine(function() {
    while (true) { // wait for a mousedown
        var event = yield;
        if (event.type == 'mousedown') {
            while (true) { // process mousemoves until a mousedown
                var event = yield;
                if (event.type == 'mousemove') move(event);
                if (event.type == 'mouseup') break;
            }
        }
    }
});
</pre>
    <p>This ends up being a pretty direct translation of our description into code.
      We can make it slightly more concise by noticing that event objects are always 'truthy',
      so we can change the while loops to:</p>
    <pre class="prettyprint">while (event = yield) { ... }</pre>
    <p>This form of infinite loop is the heart of a coroutine event loop.</p>

    <p>Here is the final implementation of the draggable box using a coroutine event loop:</p>
<pre class="prettyprint">
function move(event) {
    $('#box').css({left: event.pageX, top: event.pageY});
}

var loop = coroutine(function() {
    var event;
    while (event = yield) {
        if (event.type == 'mousedown') {
            while (event = yield) {
                if (event.type == 'mousemove') move(event);
                if (event.type == 'mouseup') break;
            }
        }
    }
});

$('#box').mousedown(loop);
$(window).mousemove(loop).mouseup(loop);
</pre>


    <h2>Coroutines as State Machines</h2>

    <p>Let's return to the <code>clock</code> example earlier.
      We can implement it using coroutines as above,
      or we can of course implement it without coroutines, using a normal function and a variable:</p>
    <div class="figure left">
<pre class="prettyprint">
var clock = coroutine(function() {
    while (true) {
        yield;
        console.log('Tick!');
        yield;
        console.log('Tock!');
    }
});
</pre>
        <p>clock as a coroutine</p>
    </div>
    <div class="figure left">
<pre class="prettyprint">
var ticking = true;
var clock = function() {
    if (ticking)
        console.log('Tick!');
    else
        console.log('Tock!');
    ticking = !ticking;
}
</pre>
        <p>clock as a function and a variable</p>
    </div>
    <div class="clear"></div>

    <div class="figure right">
      <img src="clock.svg">
      <p>the clock state machine</p>
    </div>
    <div class="clear figure right">
      <img src="dragging.svg">
      <p>the dragging state machine</p>
    </div>
    <p>Both implementations behave the same, and implement the same simple 2-state machine, as pictured.</p>
    <p>The interesting difference between the two implementations
      is that the coroutine version involves no <code>ticking</code> variable,
      and never explicitly stores any state.</p>
    <p>Without using coroutines you <em>must</em> use a variable to store the state of whether the next call should tick or tock.</p>
    <p>This variable can only be avoided because <strong>coroutines add an entirely new form of state</strong> to the language,
      namely the state of where the coroutine is currently suspended.</p>
    <p>One benefit of this 'implicit' coroutine state is that it is guaranteed to be consistent.
      This differs from the variable state, which could easily become invalid if we do something like <code>ticking="maybe"</code>.</p>

    <p>Similarly, here are the two implementations and a state diagram for the dragging example.
      Once again the coroutine implementation uses no explicit state, while the callback version must:</p>

    <div class="figure left">
<pre class="prettyprint">
var loop = coroutine(function() {
    var event;
    while (event = yield) {
        if (event.type == 'mousedown') {
            while (event = yield) {
                if (event.type == 'mousemove') move(event);
                if (event.type == 'mouseup') break;
            }
        }
    }
});

$('#box').mousedown(loop);
$(window).mousemove(loop).mouseup(loop);
</pre>
    <p>a coroutine event loop for dragging</p>
    </div>

    <div class="figure left">
<pre class="prettyprint">
var dragging = false;
function onmousedown(event) {
    dragging = true;
}
function onmousemove(event) {
    if (dragging)
        move(event);
}
function onmouseup(event) {
    dragging = false;
}

$('#box').mousedown(onmousedown);
$(window).mousemove(onmousemove).mouseup(onmouseup);
</pre>
    <p>callbacks and a variable for dragging</p>
    </div>


    <h2>Conclusion</h2>

    <p>These example coroutine event loops are no better than the equivalent callback implementations,
      but there may be more complex state machines which would benefit from coroutine implementations.</p>
    <p>This may be particularly true in node.js, where callbacks are used for more than just interface events.</p>
    <p>Of course, the <code>yield</code> keyword is undeniably useful for building <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Iterators_and_Generators#Generators.3A_a_better_way_to_build_Iterators">generators</a>,
      so I expect it will make its way into Javascript soon enough,
      regardless of the usefulness of coroutines.</p>
    <p>This writeup was inspired by and is largely just an elaboration on the section "Coroutines and Event Dispatching"
      of David Beazley's mind-blowing presentation <em><a href="http://www.dabeaz.com/coroutines/Coroutines.pdf">A Curious Course on Coroutines and Concurrency</a></em>
      starting on page 53.</p>

    <h2>Addendum &ndash; Functions Instead Of Objects</h2>

    <p>I think Javascript 1.7's verbatim copying of Python's coroutine/generator objects is a little awkward.</p>
    <p>For my uses, it would be better if calling a coroutine returned a function, equivalent to <code>send</code> (which is what the <code>coroutine</code> wrapper above does).
      Then you'd use a coroutine like:</p>
<pre class="prettyprint">
function test() {
    console.log('Hello!');
    var x = yield;
    console.log('First I got: ' + x);
    var y = yield;
    console.log('Then I got: ' + y);
}

var tester = test();
tester(); // prints 'Hello!'
tester('a dog'); // prints 'First I got: a dog'
tester('a cat'); // prints 'Then I got: a cat'
</pre>
    <p>This would work for both coroutines and <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Iterators_and_Generators#Ge\
nerators.3A_a_better_way_to_build_Iterators">generators</a>,
      because in Javascript calling <code>send()</code> is equivalent to <code>send(undefined)</code> which is equivalent to <code>next()</code>,
      so there's no need for two separate functions.</p>
    <p>The issue with this approach is that you'd lose the <code>close</code> method of coroutine/generator objects,
      which is probably useful sometimes, oh well :'(</p>

    <div class="footer">Harold Cooper, November 2012</div>

  </body>
</html>
