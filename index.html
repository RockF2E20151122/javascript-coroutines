<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="normalize.css" />

    <link rel="stylesheet" type="text/css" href="prettify.css" />
    <script src="prettify.js"></script>

    <link rel="stylesheet" type="text/css" href="index.css" />
  </head>

  <body onload="prettyPrint();">

    <h1>Coroutine Event Loops in Javascript</h1>

    <p>Javascript 1.7, currently only available in Firefox, introduces a <code>yield</code> keyword for implementing generators and coroutines.<p>
    <p>Coroutines can be used to implement event loops as an alternative to callback functions,
      which makes them particularly interesting in Javascript, where the use of callbacks is pervasive.</p>
    <p>First I'll review the basics of coroutines, but you can <a href="#loops">skip ahead</a> to the discussion of coroutine event loops.</p>


    <h2>The Basics</h2>

    <p>A coroutine is a function which can suspend itself anywhere in its execution using the <code>yield</code> keyword.</p>
    <p>It can be resumed at any later point by <em>sending</em> a value to the suspended coroutine. The sent value will appear as the return value of <code>yield</code> and execution will resume until the next <code>yield</code>.</p>

    <p>For example we can create a simple coroutine which will yield twice and print out the values that are sent to it after each yield:</p>
<pre class="prettyprint">
function test() {
    console.log('Hello!');
    var x = yield;
    console.log('First I got: ' + x);
    var y = yield;
    console.log('Then I got: ' + y);
}
</pre>

    <p>To initiate an instance of a coroutine you just call the function, which returns a coroutine object:</p>
    <pre class="prettyprint">var tester = test(); // no output yet</pre>
    <p>So far none of the function will have executed, so we must execute the function until it hits a <code>yield</code>, by calling:</p>
    <pre class="prettyprint">tester.send(); // outputs 'Hello!'</pre>
    <p>Now <code>tester</code> is paused at the first <code>yield</code>, and we can resume the coroutine by sending a value to the <code>yield</code> where it is paused:</p>
    <pre class="prettyprint">tester.send('a cat'); // outputs 'First I got: a cat'</pre>
    <p>Now <code>tester</code> is paused at the second <code>yield</code>, and we can send another value:</p>
    <pre class="prettyprint">tester.send('a dog'); // outputs 'Then I got: a dog'</pre>

    <p>That's about all there is to coroutines&mdash;they are functions which can suspend themselves using the <code>yield</code> keyword,
      and you can communicate with them by sending values, which will be returned as the value of <code>yield</code> and resume execution.</p>


    <h2>The Convenient <code>coroutine</code> Wrapper</h2>

    <p>Every time you use a coroutine you always do three things:</p>
    <ol>
      <li>Call the underlying function and store the resulting coroutine object.</li>
      <li>Call <code>send()</code> on the coroutine object, to execute until the first <code>yield</code>.</li>
      <li>After that all you can do is call <code>send(...)</code> to run the coroutine and send it values.</li>
    </ol>

    <p>We can put all of this functionality into a wrapper function:</p>
<pre class="prettyprint">
function coroutine(f) {
    var o = f(); // instantiate the coroutine
    o.send(); // execute until the first yield
    return function(x) {
        o.send(x);
    }
}
</pre>
    <p>This sets up the coroutine and returns a function which we can call directly instead of calling <code>send</code> on the coroutine object.</p>

    <p>Using this wrapper, our earlier example becomes:</p>
<pre class="prettyprint">
var test = coroutine(function() {
    console.log('Hello!');
    var x = yield;
    console.log('First I got: ' + x);
    var y = yield;
    console.log('Then I got: ' + y);
});
// outputs 'Hello!'

test('a dog'); // outputs 'First I got: a dog'
test('a cat'); // outputs 'Then I got: a cat'
</pre>

    <h2>A Coroutine Clock</h2>

    <p>Our first example coroutine yields twice and then ends. Let's make a never-ending coroutine instead.</p>
    <p>Here's a coroutine that never ends, and each time you resume it, it alternates between ticking and tocking:</p>

<pre class="prettyprint">
var clock = coroutine(function() {
    while (true) {
        yield;
        console.log('Tick!');
        yield;
        console.log('Tock!');
    }
});

clock.send(); // outputs 'Tick!'
clock.send(); // outputs 'Tock!'
clock.send(); // outputs 'Tick!'
</pre>

    <p><em>Note that in Javascript, calling <code>send()</code> with no argument is the same as calling <code>send(undefined)</code>,
      which in this case is fine since the coroutine doesn't even look at the sent values coming out of <code>yield</code>.</em></p>

    <p>Now let's make this clock tick/tock once every second. It's very easy:</p>
    <pre class="prettyprint">setInterval(clock, 1000);</pre>
    <p>Now we are resuming the coroutine once every 1000ms, and it will tick and tock for eternity.</p>

<pre class="prettyprint">
var tick = true;
function tickTock() {
    if (tick)
        console.log('Tick!');
    else
        console.log('Tock!');
    tick = !tick;
}

setInterval(tickTock, 1000);
</pre>

<pre>A<->B</pre>

    <p>Javascript 1.7 adds support for Python-style generators and coroutines, using the <code>yield</code> keyword.</p>
    <p>Javascript makes extensive use of callbacks, which make Javascript coroutines particularly interesting because they can be used to 'invert' multiple callbacks into a single imperative event loop.</p>

    <h2>For Example: A Draggable Div</h2>

    <p>Below are two implementations of a draggable div, one using standard Javascript callbacks, the other using a coroutine event loop.
      The coroutine implementation requires Firefox, which is currently the only browser that supports Javascript 1.7.</p>
    <p>Comparing the code side-by-side, you can see the structural difference between multiple callbacks and a single event loop.</p>

    <div class="figure left">
      <p>draggable div using callbacks:</p>
      <p><iframe src="test.html" width="400px" height="400px"></iframe></p>
<pre class="prettyprint">
var dragging = false;
function onmousedown(event) {
    dragging = true;
}
function onmousemove(event) {
    if (dragging)
        move(event);
}
function onmouseup(event) {
    dragging = false;
}

// register the listeners:
$('#box').mousedown(onmousedown);
$(window).mousemove(onmousemove)
    .mouseup(onmouseup);
</pre>
    </div>

    <div class="figure left">
      <p>draggable div using a coroutine event loop: (Firefox only)</p>
      <p><iframe src="test-yield.html" width="400px" height="400px"></iframe></p>
<pre class="prettyprint">
var loop = coroutine(function() {
    var event;
    while (event = yield) {
        if (event.type == 'mousedown') {
            while (event = yield) {
                if (event.type == 'mousemove') move(event);
                if (event.type == 'mouseup') break;
            }
        }
    }
});

// register the listeners:
$('#box').mousedown(loop);
$(window).mousemove(loop)
    .mouseup(loop);
</pre>
    </div>

    <h3 class="clear">Notes</h2>
    <ul>
      <li><code>move(event)</code> is defined elsewhere and simply moves the div.</li>
      <li><p><code class="prettyprint">while (event = yield) { ... }</code>
        is equivalent to:</p>
        <p><code class="prettyprint">while (true) { event = yield; ... }</code>
        since we will never send anything 'falsey' to the coroutine.</p>
        <p>This just makes for more concise event loop syntax, in my opinion.</p></li>
    </ul>

    <h2>How It Works</h2>

    <p><code>loop()</code> is always in one of two states, depending on which <code>yield</code> it is blocked on:</p>
    <ol>
      <li>At the outer <code>yield</code> it loops through events until it receives a mousedown, at which point it enters the inner loop.</li>
      <li>Then it moves to the inner <code>yield</code>, where it processes mousemoves until it receives a mouseup, at which point it breaks back to the outer loop.</li>
    </ol>

    <p>We register event listeners that send events to <code>loop()</code> such that the <code>yield</code> statements returns events as they happen:</p>
    <ol>
      <li>We instantiate the coroutine with <code class="prettyprint">var handler = loop();</code></li>
      <li>We call <code class="prettyprint">handler.send();</code> to 'prime' the coroutine by running it until it blocks on the first <code>yield</code>.</li>
      <li>We define the <code>send</code> function which simply sends its argument to the coroutine, and is thus the perfect function to register as a callback on all the events we wish to be sent to the coroutine.</li>
    </ol>
    <p>So now each event we are listening to is sent to the coroutine, and it resumes at whichever <code>yield</code> it is blocked on, with the sent event being returned as the value of <code>yield</code>.</p>

    <h2>Explicit And Implicit State</h2>
    <div class="figure right">
      <img src="dragging.svg">
      <p>the dragging state machine</p>
    </div>

    <p>Both approaches implement the same state machine, using completely different mechanisms:</p>
    <p>In the callback approach, the state is stored explicitly in the <code>dragging</code> variable, with the two states corresponding to <code>dragging==false</code> and <code>dragging==true</code>.</p>
    <p>In the coroutine approach, the state is stored implicitly, in terms of which <code>yield</code> the coroutine is currently blocked on, with the not-dragging state corresponding to the outer <code>yield</code> and the dragging state corresponding to the inner <code>yield</code>.</p>

    <div class="clear credits">Harold Cooper, November 2012</div>

  </body>
</html>
